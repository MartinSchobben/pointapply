---
title: "Reading matlab files"
output: rmarkdown::html_vignette
bibliography: ["packages.bib", "SIMS_method.bib"]
biblio-style: apalike
vignette: >
  %\VignetteIndexEntry{Reading matlab files}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```


The R package `pointapply` contains the code and data to reconstruct the publication: Martin Schobben, Michiel Kienhuis, and Lubos Polerecky. 2021. *New methods to detect isotopic heterogeneity with Secondary Ion Mass Spectrometry*, preprint on [Eartharxiv](https://eartharxiv.org/).


# Introduction 

The ion count data encompasses Secondary Ion Mass Spectrometry (SIMS) analyses by a  *Cameca NanoSIMS 50L* (Utrecht University) on the certified reference standard MEX [ @Jochum2008; @Rollion-Bard2007], which is an sedimentary carbonate, and the (uncertified) crystalline calcite MON.

The following packages are used in the for the examples and layout of the document. 


```{r setup, eval = TRUE}
library(point) # regression diagnostics
library(pointapply) # load package
```


The package `point` [@point] is especially designed to perform the intra- and inter-isotope tests highlighted in the publication.


# Download data

The raw ion count data is generated with Look\@NanoSIMS [@Polerecky2012] as LANS and comes in matlab format. Raw data files should first be downloaded from the external [Zenodo](https://doi.org/10.5281/zenodo.4580159) repository with the function `download_point()`. Consecutively, these raw data files can be transformed into the right format with the  *point* R package [@point]. 


```{r data}
# use download_point() to obtain processed data.
# this only has to be done once after installation
download_point(type = "raw")
```


# Extract ion count data

## The two "real" datasets of Schobben, Kienhuis and Polerecky 2021

The two "real" ion mapping datasets (as opposed to simulated data) are included as external data (`inst/ext-data` directory) in the package  `pointapply`, and the pathways can be conveniently generated by the function `get_matlab()`. 


```{r getmatlab}
get_matlab("2020-08-20-GLENDON") # MEX 
```


Matlab files were generated by the nanoSIMS imaging software Look\@NanoSIMS [@Polerecky2012]. This program contains algorithms for the alignment of pixels across successive depth, or depth-frames, of the ion mapping protocol. 

The matlab-generated files contain multidimensional hyper-arrays (or 'data cubes'), where ion count measurements have three spatial coordinates; width 256 pixels, height 256 pixels and 400 frames of depth, and can gave several bandwidths, which represent the different chemical species analysed by nanoSIMS. The function `read_matlab()` loads those matlab files into the R environment, and heavily relies on two R packages; `R.matlab` [@R.matlab] for loading matlab files, and `cubelyr` [@cubelyr] to make a long format data frames out of multidimensional arrays.

The functions is designed to aggregate over a specified dimension (e.g. `height` see example below) and a set of species (e.g. `c("12C", "13C")` see example below). The grid-cell size for aggregation can be set by the `grid_cell` argument, which should be an integer exponent with base two (64 pixels by 64 pixels in this example).


```{r read}
read_matlab(get_matlab("2020-08-20-GLENDON"), height, "MEX", c("12C", "13C"), 
            grid_cell = 64)
```

The `tibble` contains the following variables:

* `dim.nm`: The step value for the dimensional scale for aggregation in pixels (if `plane = height` or `plane = width`) or depth-frames (if `plane = depth`).  
* `grid.nm`: Grid-cell number.
* `dim_name.nm`: The name for the dimensional scale for aggregation (e.g. height).
* `grid_size.nm`: Convert to pixels to grid-cell size (e.g. $\mu$m) dimensions, with the arguments `scaler` which defaults to `r round(40 / 256, 2)`$\,\mu$m pixel^-^.
* `N.rw`: The ion counts.
* `t.nm`: The time increments, which are based on $1\,$milisecond per pixel. 
* `species.nm`: The chemical species name.
* `file.nm`: The original file name.
* `sample.nm`: The sample name, as provided through the `title` argument of the function.


## Grid-cell size

The grid-cell size has important consequences for the data structure of the ion count measurements, and this is further explored in the paper and the vignette *Validation of regression assumptions* (`vignette("regression")`). One can visualise the layout of the grid in a two dimensional representation, as follows (Supplementary Fig. 2). This representation could be said to resemble a flattened cardboard box.


```{r sketch}
# generate sketch of grid layout
gg_sketch() 
# save
save_point("grid_sketch", ggplot2::last_plot(), width = 12, height = 12, 
           unit = "cm")
```


```{r echo=FALSE, eval=TRUE, fig.cap = "Sketch of the grid layout with grid-cell size of 64 pixels by 64 pixels.", out.width="90%"}
knitr::include_graphics("figures/grid_sketch.png")
```


## Read data for different grid-cell sizes and planes

The following code was use to produce data aggregation for ^12^C and ^13^C over different grid-cell sizes. This was done to allow an assessment of the sensitivity of the intra- and inter-isotope tests towards the internal data structure, where smaller dimensions cause the underlying structure to deviate from a Gaussian distribution (see vignette *Validation of regression assumptions* (`vignette("regression")`) and the original paper). 


```{r all}
# planes for aggregating data and only filter for 13C and 12C
ls_planes <- rlang::quos(width, height, depth)
# 4, 8, 16, 32, 64, and 128 px grid-cell size  for aggregating data
vc_px <- sapply(2:7, function(x) 2 ^ x)

# small wrapper function to conveniently map over planes for aggregation
plane_fun <- function(directory, grid_cell, title, file_name, species = NULL){ 
  ls_rw <- purrr::map(
    ls_planes, 
    ~read_matlab(directory = directory, plane = !!(.x), title = title, 
                 species = species, grid_cell = grid_cell)
    ) %>% 
    rlang::set_names(nm = sapply(ls_planes, rlang::as_name))
  # make corrections, check point package for documentation
  ls_pr <- purrr::map(ls_rw, ~point::cor_IC(.x, .bl_t = 0, .det = "EM"))
  name <- paste(file_name, grid_cell, title, sep = "_")
  if (grid_cell == 1) name <- paste(file_name, title, sep = "_")
  assign(name, ls_pr)
  rlang::exec("write_point", rlang::sym(name))
  }

# execute
purrr::walk(
  vc_px, 
  ~plane_fun(
    get_matlab("2020-08-20-GLENDON"), 
    .x, 
    "MEX", 
    "map_sum_grid",  
    c("12C", "13C")
    )
  )
purrr::walk(
  vc_px, 
  ~plane_fun(
    get_matlab("2020-08-28-GLENDON"), 
    .x, 
    "MON", 
    "map_sum_grid",  
    c("12C", "13C")
    )
  )
```


## Read data for raster images

By keeping grid-cell size to 1 pixel we can also produce ion maps for each of the planes of ion count aggregation.


```{r raster}
# raster images
plane_fun(get_matlab("2020-08-20-GLENDON"), 1, "MEX", "map_raster_image")
plane_fun(get_matlab("2020-08-28-GLENDON"), 1, "MON", "map_raster_image")
```


## Read data for selected grid-cells

Load full datasets for two selected grid-cells on the depth plane (2 and 9, see Figure above for orientation) on the 64 pixel by 64 pixel sized grid for MEX.


```{r full}
# full datasets for grid-cell 2 and 9 of the depth plane
ls_GC <- purrr::map(
  c(2, 9), 
  ~read_matlab(
    get_matlab("2020-08-20-GLENDON"),
    plane = depth,
    title = "MEX", 
    output = "complete", 
    grid_sel = .x
    )
  ) %>% 
  rlang::set_names(nm = paste("map_full_grid_64", c(2, 9), "MEX", sep = "_"))
assign("map_full_grid_64_MEX", ls_GC)
write_point(map_full_grid_64_MEX)
```


# References
