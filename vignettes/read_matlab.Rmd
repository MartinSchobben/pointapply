---
title: "read_matlab"
output: rmarkdown::html_vignette
bibliography: /home/amandus/Documents/work/library/biblio.bib
biblio-style: apalike
vignette: >
  %\VignetteIndexEntry{read_matlab}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```


```{r pkgs, include=FALSE, message=FALSE, eval=TRUE}

# Required packages
pkgs <- miscutils::pkg_refworker(
  c("tidyverse", "Cairo", "bibtex", "R.matlab", "cubelyr", "rlang"),
  "library.bib",
  "biblio.bib"
  )     

```


# Reading the matlab files

The following packages are used in the for the examples and layout of the document. 


```{r setup, eval=TRUE}
library(point)
library(pointapply)
```


Most importantly are the package `point`, containing the intra- and inter-isotope tests highlighted in the publication, and the package `pointapply` containing the code and data to reconstruct the publication.


# The two "real" datasets in Schobben, Kienhuis and Polerecky 2021

The two "real" ion mapping datasets (as opposed to simulated data) are included as external data (`inst/ext-data` directory) in the package  `pointapply`, and the pathways can be conveniently generated by the function `get_matlab()`. This external data encompasses the sedimentary carbonate MEX [@Jochum2008] and the crystalline calcite MON, as used in the study [@Schobben].


```{r getmatlab, eval = TRUE}

get_matlab("2020-08-20-GLENDON") # MEX 

```


Matlab files were generated by the nanoSIMS imaging software Look\@NanoSIMS [@Polerecky2012]. This program contains algorithms for the alignment of pixels across successive depth, or depth-frames, of the ion mapping protocol. 

The matlab-generated files contain multidimensional hyper-arrays (or data cubes), where measurements in have three spatial coordinates; the width $256\,\text{px}$, the height $256\,\text{px}$ and $256\,\text{frames}$ of depth, and can gave several bandwidths, which represent the different chemical species analysed with nanoSIMS. The function `read_matlab` can read these files, and is largely based on two important R packages; *R.matlab* [@R.matlab] for loading matlab files, and *cubelyr* [@cubelyr] in order to make a long format dataframe out of multidimensional array.


```{r read}

read_matlab(get_matlab("2020-08-20-GLENDON"), height, "MEX")

```

The `tibble` contains the following variables:

* `dim.nm`: The step value for the dimensional scale for aggregation in pixels (if `plane = height` or `plane = width`) or depth-frames (if `plane = depth`).  
* `grid.nm`: Grid-cell size (often $\mu$m) dimensions converted to pixel with the arguments `scaler` which is `r 40 / 256`$\,\mu$m pixel^-^.
* `dim_name.nm`: The name for the dimensional scale for aggregation (e.g. height).
* `N.rw`: The ion counts.
* `t.nm`: The time increments, which are based on $1\,$milisecond per pixel. 
* `species.nm`: The chemical species name.
* `file.nm`: The original file name.
* `sample.nm`: The sample name, as provided through the `title` argument of the function.

# Read data for different grid-cell sizes and planes

The following code was use to produce data aggregation over different grid-cell sizes. This was done to allow an assessment of the sensitivity of the intra and inter isotope tests towards the internal data structure, where smaller dimensions cause the underlying structure to deviate from a Gaussian distribution (see vignette and the original paper). 


```{r all}

# planes for aggregating data
ls_planes <- quos(width, height, depth)
# 4, 8, 16, 32, 64, and 128 px grid-cell size  for aggregating data
vc_px <- sapply(4:7, function(x) 2 ^ x)

# small wrapper function to conveniently map over planes for aggregation
plane_fun <- function(directory, grid_cell, title){ 
  ls_rw <- map(
    ls_planes, 
    ~read_matlab(directory = directory, plane = !!(.x), title = title, 
                 grid_cell = grid_cell)
    ) %>% set_names(nm = sapply(ls_planes, as_name))
  # make corrections, check point package
  ls_pr <- map(ls_rw, ~point::cor_IC(.x, .bl_t = 0, .det = "EM"))
  name <- paste("map_sum_grid", grid_cell, title, sep = "_")
  assign(name, ls_pr)
  do.call("use_data", list(as.name(name), overwrite = TRUE, compress = "xz"))
  }


walk(vc_px, ~plane_fun(get_matlab("2020-08-20-GLENDON"), .x, "MEX"))
walk(vc_px, ~plane_fun(get_matlab("2020-08-28-GLENDON"), .x, "MON"))

```



# Read data for raster images

By keeping grid-cell size to 1 pixel


```{r raster}

map_raster_MEX <- plane_fun(get_matlab("2020-08-20-GLENDON"), 1, "MEX")
map_raster_MON <- plane_fun(get_matlab("2020-08-28-GLENDON"), 1, "MON")


```
